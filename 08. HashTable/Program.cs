
namespace _08._HashTable
{
    internal class Program
    {
        /******************************************************
		 * 해시테이블 (HashTable)
		 * 
		 * 키 값을 해시함수로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식
		 * 해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑
		 ******************************************************/
        //처음에 공간을 많이 만들어서 쓰기 때문에 속도는 포기
        //빈공간이 있을 수 있음

        // <해시테이블의 시간복잡도>
        // 접근			탐색			삽입			삭제
        // X			O(1)		O(1)		O(1)

        // <해시함수의 조건>
        // 1. 입력에 대한 해시함수의 결과가 항상 동일한 값이어야함. ( 1 : 1 )

        // <해시함수의 효율>
        // 1. 해시 함수 자체가 느린 경우 의미가 없음. (글자 획수 vs 글자 획수에 뭐 더하고 곱하고)
        // ㄴ 인덱스값을 가져오는 데 처리과정이 복잡하면 안 된다 <- 해싱함수의 역할
        // 키 값을 인덱스로 바꾸는 것 == 해시 / 방법 == 해싱함수
        // 2. 해시함수의 결과가 밀집도가 낮아야 함.
        // 3. 해시테이블의 크기가 클수록 효율이 좋다.
        // 많이 겹치면 재해싱함 테이블 공간 사용률이 70 ~ 80% 에 이르면 성능 저하 -> 공간 확대

        //열거형을 이용하기도 함

        // <해시테이블 주의점 - 충돌>
        // 해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것
        // 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음
        // 대표적인 충돌 해결방안으로 체이닝과 개방주소법이 있음

        // <충돌해결방안 - 체이닝> <- 노드기반이라 c#에서는 안 쓰임
        // 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
        // 222에(동일한 키 값에) 연결리스트를 저장하고 여러 값들을 저장함
        // 장점 : 해시테이블에 자료가 많아지더라도 성능저하가 적음
        // 단점 : 해시테이블 외 추가적인 저장공간이 필요

        // <충돌해결방안 - 개방주소법>
        // 해시 충돌이 발생하면 다른 빈 공간(다음공간, 그 다음 공간 ...)에 데이터를 삽입하는 방식
        // 해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정
        // 장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
        // 단점 : 해시테이블에 자료가 많아질수록 성능저하가 많음
        // 해시테이블의 공간 사용률이 높을 경우 성능저하가 발생하므로 재해싱 과정을 진행함
        // 재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱 

        void Dictionary()
        {
            //Hashtable은 오브젝트로 해서 잘 안 쓴다
            Dictionary<string, Item> dictionary = new Dictionary<string, Item>();

            //추가
            dictionary.Add("초기아이템", new Item("초보자용 검", 10));
            dictionary.Add("초기방어구", new Item("초보자용 가죽갑옷", 30));
            //똑같은 키 값이 중복되면 안 된다
            //키 값 스트링 자체는 한글로 써도 문제 없다

            //탐색
            Console.WriteLine(dictionary["초기아이템"]);

            //삭제
            dictionary.Remove("초기방어구");

            //확인
            bool IsContain = dictionary.ContainsKey("초기아이템");
            //dictionary.TryGetValue
        }

        static void Main(string[] args)
        {
            
        }
        public class Item
        {
            public string name;
            public string imagePath;
            public int weight;

            public Item(string name, int weight)
            {
                this.name = name;
                this.weight = weight;
            }
        }
    }
}