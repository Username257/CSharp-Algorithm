namespace SortAssignment
{
    internal class Program
    {
        /*
            1. 선형정렬 3종 구현 원리 조사
               - 선택정렬, 삽입정렬, 버블정렬
            2. 분할정복정렬 3종 구현 원리 조사(동작 방법)
               - 힙정렬, 합병정렬, 퀵정렬
            3. 분할정복정렬 3종의 원리에 의한 특징 조사(원리에 의한 특징 메모리 최악의 경우)
               (힙정렬 특징, 병합정렬 특징, 퀵정렬 특징)
        */

        /*
         * 선택정렬(selection sort)
         * 제자리 정렬이다. - 입력 배열 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
         * 
         * 과정
         * 1. 주어진 배열 중에서 최솟값을 찾는다
         * 2. 그 값을 맨 앞에 위치한 값과 교체한다
         * 3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다
         * 4. 하나의 원소만 남을 때까지 위의 1 ~ 3 과정을 반복한다
         * 4에서 1 ~ 3과정을 반복하며, 회전을 수행하고나면 가장 작은 값의 자료가 맨 앞에 오게
         * 되므로 1회전에 자료 하나를 정렬 하고, 정렬된 자료는 다음 회전 때 고려하지 않는다.
         * 
         * 장단점
         * 장점 - 자료 이동 횟수가 미리 결정된다
         * 단점 - 안정성을 만족하지 않는다(같은 값의 자료의 경우에 상대적인 위치가 변경될 수 있다)
         * 
         * 시간복잡도는 n^2 
         */

        /*
         * 삽입정렬(insertion sort)
         * 오름차순을 기준으로 정렬한다
         * 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열부분과 비교하고,
         * 자신의 위치를 찾아 삽입한다
         * 
         * 과정
         * 두 번째 자료부터 시작해서 그 앞의 자료들과 비교해 삽입할 위치를 지정하고
         * 자료를 뒤로 한 칸씩 옮기고 그 자리에 들어간다.
         * 
         * 장단점
         * 장점 - 안정성을 만족한다, 자료의 수가 적을 경우 알고리즘이 간단해서 유리하다
         *        대부분의 자료가 이미 정렬되어 있는 경우에 매우 효율적이다
         * 단점 - 비교적 많은 자료들의 이동을 포함한다. 자료의 수가 많을 경우 적합하지 않다
         * 
         * 시간 복잡도는 n^2
         */

        /*
         * 버블정렬(bubble sort)
         * 서로 인접한 두 원소를 검사하여 정렬한다
         * 
         * 과정
         * 서로 인접한 두 원소를 비교하며, 더 큰 자료가 뒤로 이동한다.
         * 1회전이 끝나면 가장 큰 자료가 맨 뒤로 이동하고, 2회전 때 맨 뒤의 자료는
         * 고려하지 않는 식으로 정렬에서 제외되는 데이터가 하나씩 늘어난다
         * 
         * 장단점
         * 장점 - 구현이 매우 간단하다
         * 단점 - 하나의 요소가 가장 왼쪽에서 오른쪽으로 이동하기 위해서 드는 비용이 많다
         * 이동 작업보다 교환 작업이 더 복잡하기 때문에, 거의 쓰이지 않는다.
         * 
         * 시간 복잡도는 n^2
         */

        /*
         * 힙정렬(heap)
         * 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.
         * 최댓값, 최솟값을 추출할 수 있다.
         * 
         * 과정
         * 힙에 새로운 요소가 들어오면, 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다
         * 새로운 노드를 부모 노드들과 비교하며 힙의 성질을 만족시킨다.
         * 최대힙의 경우 새로운 노드가 부모 노드보다 클 경우 부모 노드와 위치를 교환한다
         * 루트 노드가 최댓값임으로, 루트 노드를 삭제 시 최댓값을 배출한다.
         * 삭제된 루트 노드에 힙의 마지막 노드를 가져와 자식 노드와 비교하며 힙을 재구성한다
         * 
         * 장단점
         * 장점 - 시간 복잡도가 좋다. 최댓값/최솟값을 구할 때 편리하다
         * 
         * 시간 복잡도는 nlog2n
         * 힙 트리의 전체 높이가 log2n이므로, 요소를 삽입/삭제시 힙을 재정비하며 log2n이 소요된다
         */

        /*
         * 합병정렬
         * 오름차순을 기준으로 정렬한다. 안정 정렬에 속하며, 분할 정복 알고리즘의 하나다.
         * 분할 정복 알고리즘 - 문제를 작은 문제들로 분리하고 각각을 해결한 다음, 결과를
         * 모아서 원래의 문제를 해결하는 전략이다.
         * 
         * 과정
         * 하나의 리스트를 두 개의 균들한 크기로 분할하고 각각을 정렬한 다음 합한다
         * 원소가 2개가 될 때까지 나눠서, 2개의 원소 중 큰 값(혹은 작은 값)을 뒤로 배치시킨다
         * 2개의 분리된 리스트가 합쳐질 때 역시 원소 하나하나를 비교한다
         * 이 과정에서 원래 리스트의 요소들을 새로운 리스트로 옮긴 후, 정렬 후 다시 원래의 리스트로
         * 옮긴다.
         * 
         * 장단점
         * 장점 - 만약 연결리스트를 활용한다면 링크의 주소만 변경하면 되므로 부담이 적어진다
         * 단점 - 배열을 활용한다면 임시 배열이 필요하다. 이 경우 요소들의 크기가 크다면 부담이 된다.
         * 
         * 시간 복잡도는 nlog2n
         */

        /*
         * 퀵정렬
         * 불안정 정렬에 속하며, 비교 정렬에 속한다. 분할 정복 알고리즘의 하나로, 매우 빠른
         * 속도를 갖는다.
         * 
         * 과정
         * 리스트 안에 있는 한 요소를 선택한다. 이를 피벗이라 칭한다.
         * 피벗을 기준으로 작은 요소들은 피벗의 왼쪽으로 / 큰 요소들을 오른쪽으로 옮긴다
         * 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트에서 피벗을 각각 정한 후 정렬한다(반복)
         * 
         * 장단점
         * 장점 - 속도가 빠르다. 추가 메모리 공간을 필요로 하지 않는다
         * 단점 - 정렬된 리스트에서는 시간이 더 걸린다. 
         * 
         * 시간 복잡도는 nlog2n
         * 
         * 최선의 경우, 비교 횟수는 log2n이다.
         * 전체 리스트의 요소들을 비교해야하므로, 비교 연산은 n번이다.
         * 이동횟수는 비교 연산보다 적으므로 무시한다. -> nlog2n
         * 
         * 최악의 경우, 이미 정렬된 리스트에 퀵 정렬을 실행할 경우나 리스트가 계속 불균형하게
         * 나누어질 경우, 비교 횟수는 n번이 된다.
         * 전체 리스트의 요소들을 비교해야하므로, 비교 연산은 n번
         * 이동횟수는 비교 연산보다 적으르모 무시 -> n^2
         */


        static void Main(string[] args)
        {
            
        }
    }
}