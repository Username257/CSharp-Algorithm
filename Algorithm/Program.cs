namespace Algorithm
{
    internal class Program
    {
        static void Main(string[] args)
        {

            //자료구조는 데이터를 상황에 맞게 저장하기 위한 구조이고,
            //알고리즘은 자료구조에 있는 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 방법들의 모임
            
            /* 
             * 알고리즘
             * 문제를 해결하기 위해 정해진 진행절차나 방법
             * 컴퓨터에서 알고리즘은 어떠한 행동을 하기 위해서 만들어진 프로그램 명령어의 집합
             */

            //알고리즘 조건
            //1. 입풀력 : 정해진 입력과 출력이 존재해야 함
            //2. 명확성 : 각 단체마다 단순하고 모호하지 않아야 함
            //3. 유한성 : 특정 수의 작업 이후에 정지해야 함
            //4. 효과성 : 모든 과정은 수행 가능해야 함

            //알고리즘 성능
            //1. 정확성 : 정확하게 동작하는가?
            //2. 단순성 : 얼마나 단순한가?
            //3. 최적성 : 더 이상 개선할 여지가 없을 만큼 최적화되어있는가?
            //4. 작업량 :  얼마나 적은 연산을 수행하는가?
            //5. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가?


            /*
             * 자료구조(DataStructure)
             * 프로그래밍에서 데이터를 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미
             * 데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미
             */

            //자료구조 형태
            //선형구조 : 자료 간 관계가 1:1
            //비성형구조 : 자료 간 관계가 1:n 혹은 n:n

            //알고리즘&자료구조 평가
            //컴퓨터에서 알고리즘과 자료구조의 평가는 시간과 공간 두 자원을 얼마나 소모하는지가 효율성의 중점
            //평균적인 상황에서와 최악의 상황에서 자원 소모량이 기준이 됨
            //일반적으로 시간을 위해 공간이 희생되는 경우가 많음 : 무어의 법칙(저장용량은 빠르게 발전)
            //시간복잡도 : 알고리즘의 시간적 자원 소모량
            //공간복잡도 : 알고리즘의 공간적 자원 소모량

            //Big-O 표기법
            //알고리즘의 복잡도를 나타내는 점근표기임
            //가장 높은 차수의 계수와 나머지 모든 항을 제거하고 표기
            //알고리즘의 대략적인 효율을 파악할 수 있는 수단

            // 예시 : 양의 정수 n을 n번 더하는 알고리즘
            int Case1(int n)
            {
                int sum = 0;
                sum = n * n;
                return sum;
            }
            int Case2(int n)
            {
                int sum = 0;
                for (int i = 0; i < n; i++)
                    sum += n;
                return sum;
            }
            int Case3(int n)
            {
                int sum = 0;
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        sum++;
                return sum;
            }

            // 입력값		Case1	    Case2	    Case3
            // n = 1		    1	        1	        1
            // n = 10		    1	       10	      100
            // n = 100		    1	      100	   10,000
            // n = 1000		    1	     1000	1,000,000
            // Big-O		 O(1)	     O(n)	   O(n^2)

            //O(1) > O(log n) ex)Up Down 게임 > O(n) > D(n log n) > O(n^2) > O(n^3) > O(2^n)
            //O(log n) == Up Down 중간 숫자 말하고 반절 안 봐도 되는 거
        }
    }
}